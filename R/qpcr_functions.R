#'Read a qPCR file
#'
#'Reads an Excel (.xls) file with the results from a qPCR with the data being parsed as asked in the 'columns' argument.
#'
#'@param file pathway to the xls/xlsx file which the data are to be read from. Each row of the table appears as one line of the file. If it does not contain an absolute path, the file name is relative to the current working directory
#'@param sheet string name of excel's sheet where results are stored. If not specified, the default is "Results"
#'@param results.range An Excel cell range to read from
#'@param columns  Character-based vector with the names of the columns to read from. By default column's named "Sample Name", "Target Name", "CT", "Ct Mean" are read
#'@param undet.ct string used by qPCR machine to name undetermined CT values. If not specified, the default value is "Undetermined", which ensures "CT" fields does not coerce as a character type.
#'@return A dataframe with parsed data according to the variables wirtten in the 'columns' argument
#'@export
read.qPCR <- function (file,
sheet = "Results",
results.range,
columns =  c("Sample Name",
             "Target Name",
             "CT",
             "Ct Mean"),
undet.ct = "Undetermined"
){
  if (!require(readxl)) {
    install.packages("readxl")
    library(readxl)
  }

  qPCR_table <- read_excel(path = file,
                           sheet = sheet,
                           range = results.range,
                           na = c(undet.ct, ""))
  qPCR_table <- qPCR_table[,columns]
  qPCR_table[sapply(qPCR_table, FUN = is.character)]  <-
    lapply(qPCR_table[sapply(qPCR_table, FUN = is.character)], FUN = as.factor)
  # converts 'character'-type variables to 'factor'
  return(qPCR_table)
}



#'Analyzes results from a qPCR
#'
#'Takes the results from a qPCR dataframe and returns their ∆Ct and ∆∆Ct values
#' according to a reference and the average; and both fold change and Log Fold Change
#'
#' @param qPCR_table An R data frame with the results of the qPCR, such as one generated by `read.qPCR()`.
#' @param control_cond A character indicating the condition to be considered as control or reference.
#' @param hk_genes A character vector indicating the name of the housekeeping genes.
#' @param rows A numeric vector indicating the index of the rows with samples belonging to the same experiment. By default, all rows are considered to belong to the same experiment (`1:nrow(qPCR_table)`).
#' @param sample Character indicating the name of the variable that stores sample names, `"Sample Name"` by default.
#' @param target Character indicating the name of the variable that stores target (gene) names, `"Target Name"` by default.
#' @param ct Character indicating the name of the variable that stores Ct values, `"CT"` by default.
#' @param ct_mean Character indicating the name of the variable that stores Ct mean values (mean of Ct values of replicates), `"Ct Mean"` by default.
#' @param include.ct_mean A logical value indicating whether Ct mean values (mean of Ct values of replicates) are included in the `qPCR_table` data frame, `TRUE` by default.
#' @param minus.ctrl A logical value indicating whether  ∆Ct,  ∆∆Ct, fold change and LFC are to be calculated with respect to a control or reference condition, `TRUE` by default.
#' @param minus.mean A logical value indicating whether  ∆Ct,  ∆∆Ct, fold change and LFC are to be calculated with respect to the mean value for same genes, `TRUE` by default.
#' @param ct.var numeric indicating the threshold of variation coefficient of replicate Ct values above which the user is warned that Ct value variability is too high, 0.11 by default according to ThermoFisher standards
#' @return A dataframe with ∆Ct and ∆∆Ct values according to the reference sample indicated and the average; and both fold change (2^-∆∆Ct) and LFC (log2 fold change)
#' @export
qPCR.results <- function(qPCR_table,
                         control_cond,
                         hk_genes,
                         rows = 1:nrow(qPCR_table),
                         sample =  "Sample Name",
                         target = "Target Name",
                         ct = "CT",
                         ct_mean = "Ct Mean",
                         include.ct_mean = TRUE,
                         minus.ctrl = TRUE,
                         minus.mean = TRUE,
                         ct.var = 0.11){
  if (include.ct_mean){
    qPCR_table <- unique(qPCR_table[rows,c(sample, target, ct_mean)])
    colnames(qPCR_table) <- c("Sample", "Target", "Ct.Mean")
    qPCR_table <- droplevels(qPCR_table)
  }else{
    qPCR_table <- qPCR_table[rows,c(sample, target, ct)]
    colnames(qPCR_table) <- c("Sample", "Target", "CT")

    standev <- aggregate(data = qPCR_table, CT ~ Sample + Target,
                         FUN = function(x) sd(x)/mean(x))
    colnames(standev)[3] <- "Ct.CV"
    for (i in standev$Ct.CV){
      if (i>=ct.var){
        samp <- standev$Sample[which(standev$Ct.CV == i)]
        targ <- standev$Target[which(standev$Ct.CV == i)]
        samptarg <- paste(samp, targ, sep = "_")
        warn <- paste("Sample ", samptarg,
                      " CT values have high variation (CV >= ", ct.var, ").",
                      sep = "")
        warning(warn)
      }
    }
    qPCR_table <- aggregate(qPCR_table$CT ~
                              qPCR_table$Sample + qPCR_table$Target, FUN = mean)
    colnames(qPCR_table) <- c("Sample", "Target", "Ct.Mean")
    qPCR_table <- droplevels(qPCR_table)
  }

  deltact<-function(ct_mean){
    condition_control <- qPCR_table$Sample == control_cond
    target_control <- qPCR_table$Target ==
      qPCR_table$Target[which(qPCR_table$Ct.Mean == ct_mean)]
    dct <- (ct_mean)-(qPCR_table$Ct.Mean[which(condition_control & target_control)])
    return(dct)
  }

  table <- aggregate(data = qPCR_table, Ct.Mean ~ Sample + Target, FUN = deltact)
  colnames(table) <- c("Sample", "Target", "dCt_ctrl")
  table <- merge(qPCR_table, table)

  table <- table[order(table$Target, table$Sample),]
  average_ct <- tapply(table$Ct.Mean, INDEX = table$Target, FUN = mean)
  average_ct <- rep(average_ct, each = length(levels(table$Sample)))
  table$dCt_mean <- table$Ct.Mean - average_ct

  table <- table[order(table$Sample),]
  hk_table <- table[which(table$Target %in% hk_genes),]
  hk_averages <- tapply(hk_table$dCt_mean, INDEX = hk_table$Sample, FUN = mean)
  hk_averages <- rep(hk_averages, each = length(levels(table$Target)))
  table$ddCt_ctrl <- table$dCt_ctrl - hk_averages
  table$ddCt_mean <- table$dCt_mean - hk_averages
  table$Fold.Change_ctrl <- 2^(-table$ddCt_ctrl)
  table$Fold.Change_mean <- 2^(-table$ddCt_mean)
  table$LFC_ctrl <- log2(table$Fold.Change_ctrl)
  table$LFC_mean <- log2(table$Fold.Change_mean)

  if(!(minus.ctrl & minus.mean)){
    if(!minus.ctrl & !minus.mean){
      stop("At least one argument from 'minus.ctrl' and 'minus.mean' must be TRUE.")
    }
    if(!minus.ctrl){
      eliminate <- c("dCt_ctrl", "ddCt_ctrl", "Fold.Change_ctrl", "LFC_ctrl")
      table <- table[,!(names(table) %in% eliminate)]
    }else if(!minus.mean){
      eliminate <- c("dCt_mean", "ddCt_mean", "Fold.Change_mean", "LFC_mean")
      table <- table[-which(table$Sample == control_cond),
                     !(names(table) %in% eliminate)]
    }
  }
  return(table)
}

#'
