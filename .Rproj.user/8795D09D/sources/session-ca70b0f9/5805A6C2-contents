---
title: "Proyecto 3: qPCR"
author: "Grupo 8: Pablo Baceiredo Macho, Mario Castillo García y Carlos Martín del Cerro"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 2
    toc_float:
      collapsed: false
      smooth_scroll: false
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

En nuestro grupo planteamos un conjunto de **2 funciones** que, en su conjunto, responden a todos las tareas propuestas en el proyecto. Primero presentamos las funciones y a continuación ejemplos de su uso. Por último, incluimos un anexo con una ayuda sobre los argumentos.

# Funciones

## Función `read.qPCR()`

La función `read.qPCR()` lee el archivo de excel (`.xls`) con los resultados de la qPCR -indicado en el argumento `file`- y devuelve un *data frame* con los datos parseados según las variables que indique en el argumento `columns`. Los argumentos incluidos indican:

-   `file`: el archivo a leer (y su directorio)
-   `sheet`: el nombre de la hoja, dentro del archivo, donde se encuentran los resultados
-   `results.range`: el rango de celdas donde se encuentran los resultados
-   `columns`: las variables que se quieren importar
-   `undet.ct`: los strings que se utilizan como indicativo de que el Ct es indeterminado (para convertirlos a `NA`).

Para más información sobre los argumentos: ver [Ayuda de `read.qPCR()`](#ayuda-de-read.qpcr).

```{r}
read.qPCR <- function (file, 
                       sheet = "Results", 
                       results.range, 
                       columns =  c("Sample Name", 
                                    "Target Name", 
                                    "CT", 
                                    "Ct Mean"),
                       undet.ct = "Undetermined"
                       ){
  if (!require(readxl)) {
    install.packages("readxl")
    library(readxl)
  }
  
  qPCR_table <- read_excel(path = file, 
                           sheet = sheet, 
                           range = results.range,
                           na = c(undet.ct, ""))
  qPCR_table <- qPCR_table[,columns]
  qPCR_table[sapply(qPCR_table, FUN = is.character)]  <- 
    lapply(qPCR_table[sapply(qPCR_table, FUN = is.character)], FUN = as.factor) 
  # convierte las variables de tipo 'character' a 'factor'
  return(qPCR_table) 
}
```


## Función `qPCR.results()`

La función `qPCR.results()` toma un *data frame* con resultados de qPCR y devuelve otro *data frame* con:

-   Los valores del **∆Ct** calculados respecto de
    -   una referencia
    -   la media
-   Los valores de **∆∆Ct** (ídem.)
-   Los valores de **Fold Change** ($Fold Change = 2^{-\Delta\Delta C_t}$) (ídem.)
-   Los valores de **LFC** (Log Fold Change, $LFC=log_2(FC)$) (ídem.)


La función pide los siguientes argumentos (que van cobrando sentido a medida que avanzamos en la función):

-   `qPCR_table`: *data frame* con los resultados de la qPCR (el *data frame* generado con `read.qPCR()`)
-   `control_cond`: condición que queremos utilizar como referencia (control) para el cálculo de los ∆Ct.
-   `hk_genes`: vector con los genes *housekeeping*
-   `rows`: filas del *data frame* correspondientes al experimento que queremos analizar (si es que hay más de un experimento en la placa de qPCR)
-   `sample_name`, `target_name`, `ct`, `ct_mean`: strings utilizados como nombres de las variables
-   `include.ct_mean`: logical que indica si se incluye la columna "Ct mean" en el *data frame* introducido a la función
-   `minus.ctrl` y `minus.mean`: logicals que indican si se quiere calcular los ∆Ct respecto de un control o respecto de la media, respectivamente

Para más información sobre los argumentos: ver [Ayuda de `qPCR.results()`](#ayuda-de-qpcr.results).

```{r}
qPCR.results <- function(qPCR_table, 
                       control_cond, 
                       hk_genes, 
                       rows = 1:nrow(qPCR_table), 
                       sample_name =  "Sample Name", 
                       target_name = "Target Name",
                       ct = "CT",
                       ct_mean = "Ct Mean",
                       include.ct_mean = TRUE, 
                       minus.ctrl = TRUE, 
                       minus.mean = TRUE){ 
  
  if (include.ct_mean){
    qPCR_table <- unique(qPCR_table[rows,c(sample_name, target_name, ct_mean)])
    colnames(qPCR_table) <- c("Sample.Name", "Target.Name", "Ct.Mean")
    qPCR_table <- droplevels(qPCR_table) 
  }else{
    qPCR_table <- qPCR_table[rows,c(sample_name, target_name, ct)]
    colnames(qPCR_table) <- c("Sample.Name", "Target.Name", "CT")
    qPCR_table <- aggregate(qPCR_table$CT ~ 
                              qPCR_table$Sample.Name + qPCR_table$Target.Name, 
                            FUN = mean)
    colnames(qPCR_table) <- c("Sample.Name", "Target.Name", "Ct.Mean")
    qPCR_table <- droplevels(qPCR_table) 
  } 
  
  deltact<-function(ct_mean){ 
    condition_control <- qPCR_table$Sample.Name == control_cond
    target_control <- qPCR_table$Target.Name == 
      qPCR_table$Target.Name[which(qPCR_table$Ct.Mean == ct_mean)]
    dct <- (ct_mean) - (qPCR_table$Ct.Mean[which(condition_control & 
                                                   target_control)])
    return(dct)
  }
  
  table <- aggregate(data = qPCR_table, Ct.Mean ~ Sample.Name + Target.Name, 
                     FUN = deltact) 
  colnames(table) <- c("Sample.Name", "Target.Name", "dCt_ctrl")
  table <- merge(qPCR_table, table)
  
  table <- table[order(table$Target.Name, table$Sample.Name),]
  average_ct <- tapply(table$Ct.Mean, INDEX = table$Target.Name, FUN = mean)
  average_ct <- rep(average_ct, each = length(levels(table$Sample.Name)))
  table$dCt_mean <- table$Ct.Mean - average_ct
  
  table <- table[order(table$Sample),]
  hk_table <- table[which(table$Target.Name %in% hk_genes),]
  hk_averages <- tapply(hk_table$dCt_mean, INDEX = hk_table$Sample.Name, 
                        FUN = mean) 
  hk_averages <- rep(hk_averages, each = length(levels(table$Target.Name)))
  table$ddCt_ctrl <- table$dCt_ctrl - hk_averages
  table$ddCt_mean <- table$dCt_mean - hk_averages
  table$Fold.Change_ctrl <- 2^(-table$ddCt_ctrl)
  table$Fold.Change_mean <- 2^(-table$ddCt_mean)
  table$LFC_ctrl <- log2(table$Fold.Change_ctrl)
  table$LFC_mean <- log2(table$Fold.Change_mean)
  
  if(!(minus.ctrl & minus.mean)){
    if(!minus.ctrl & !minus.mean){
      stop("At least one argument from 'minus.ctrl' and 'minus.mean' must be TRUE.")
      }
    if(!minus.ctrl){
      eliminate <- c("dCt_ctrl", "ddCt_ctrl", "Fold.Change_ctrl", "LFC_ctrl")
      table <- table[,!(names(table) %in% eliminate)] 
    }else if(!minus.mean){
      eliminate <- c("dCt_mean", "ddCt_mean", "Fold.Change_mean", "LFC_mean")
      table <- table[-which(table$Sample.Name == control_cond),
                     !(names(table) %in% eliminate)]
    }
  }
  return(table)
}
```


La función es muy larga, así que vamos a desgranarla por bloques. Para facilitar su comprensión, vamos a utilizar como ejemplo el experimento 1 de la *Plate10b.xls*, para ir viendo lo que la función realiza.

```{r echo = FALSE, include = FALSE}
qPCR <- read.qPCR(file = "Plate10b.xls", 
                  results.range = "A40:AK134")
qPCR <- qPCR[order(qPCR$`Sample Name`),] 
qPCR_table <- qPCR
control_cond <- "1Nx-"
hk_genes <- c("RP2","Act")
rows = 1:40 
sample_name =  "Sample Name" 
target_name = "Target Name"
ct = "CT"
ct_mean = "Ct Mean"
include.ct_mean = FALSE
minus.ctrl = TRUE 
minus.mean = TRUE
```


El primer paso es parsear el *data frame* para mantener sólo los datos del experimento deseado (indicado en `rows`) y cambiar los nombres de las variables para unificarlos y que sean más manejables. Puesto que no nos interesan los replicados técnicos sino su valor medio de Ct, nos quedamos solo con uno de ellos utilizando `unique()`. Esto solo lo podemos hacer **si el usuario incluye la columna *Ct Mean*** ; si no la incluye y sólo incluye la de los CT, hemos de calcular los Ct Mean. El argumento `include.ct_mean` de la función se incluye para evaluar si el usuario ha incluido la columna *Ct Mean* en el *data frame* que se le da a la función. Por defecto se considera `TRUE` porque la función `read.qPCR()` devuelve por defecto los *Ct Mean*.

```{r}
if (include.ct_mean){
    qPCR_table <- unique(qPCR_table[rows,c(sample_name, target_name, ct_mean)])
    colnames(qPCR_table) <- c("Sample.Name", "Target.Name", "Ct.Mean")
    qPCR_table <- droplevels(qPCR_table) # eliminar los levels que desaparecen
  }else{
    qPCR_table <- qPCR_table[rows,c(sample_name, target_name, ct)]
    colnames(qPCR_table) <- c("Sample.Name", "Target.Name", "CT")
    qPCR_table <- aggregate(qPCR_table$CT ~ 
                              qPCR_table$Sample.Name + qPCR_table$Target.Name, 
                            FUN = mean)
    colnames(qPCR_table) <- c("Sample.Name", "Target.Name", "Ct.Mean")
    qPCR_table <- droplevels(qPCR_table) 
  }
```

De esta manera, haya o no incluido el usuario el *Ct Mean* en el *data frame* que se le da a la función, obtenemos el mismo *data frame* con el que la función puede trabajar.


Ahora calculamos los ∆Ct con respecto a una condición control indicada por el usuario. Recordemos que, para cada condición $i$ y gen $\alpha$,

$$\Delta Ct_{i,\alpha}=Ct_{i,\alpha}-Ct_{control,\alpha}$$

Así, generamos una función `deltact` que, a cada valor de $Ct_{i}$ (en el *data frame*, "Ct.Mean", porque utilizamos el promedio de los replicados), le reste el $Ct$ del control. Este último se puede localizar en el *data frame* como el valor de la variable "Ct.Mean" que corresponde a aquel en el que tiene como "Sample.Name" el nombre de la condición control introducida como argumento a la función (en el argumento `control_cond`) y como "Target.Name" el mismo que el "Target.Name" del Ct sobre el que aplicamos la función.

Posteriormente, generamos un *data frame* aplicando esta función sobre todos los "Ct.Mean" y la conjugamos con el *data frame* introducido a la función.

```{r}
# función para calcular los dCt
deltact <- function(ct_mean){ 
  condition_control <- qPCR_table$Sample.Name == control_cond
  target_control <- qPCR_table$Target.Name ==
    qPCR_table$Target.Name[which(qPCR_table$Ct.Mean == ct_mean)]
  dct <- (ct_mean) - (qPCR_table$Ct.Mean[which(condition_control 
                                               & target_control)])
  return(dct)
}
  
# generar tabla para los dCt_ctrl = Ct - Ct_ref
table <- aggregate(data = qPCR_table, Ct.Mean ~ Sample.Name + Target.Name, 
                   FUN = deltact) 
colnames(table) <- c("Sample.Name", "Target.Name", "dCt_ctrl")
table <- merge(qPCR_table, table)

head(table[order(table$Target.Name),])

```


A continuación hacemos lo mismo, pero esta vez calculando los ∆Ct respecto de la media. Así, para cada para cada condición $i$ y gen $\alpha$,

$$\Delta Ct_{i,\alpha} = Ct_{i,\alpha}-mean(Ct_{\alpha})$$


Para ello,

1.  Ordenamos la tabla según los genes (**Target.Name**) y condiciones (**Sample.Name**).
2.  Calculamos el promedio de los Ct (**Ct.Mean**) según el gen (**Target.Name**).
3.  Generamos un vector en el que los promedios calculados en el paso "2" se repitan tantas veces como diferentes condiciones (**Sample.Name**) haya.
4.  Añadimos al *data frame* una nueva columna, **dCt_mean**, que sea la diferencia de los distintos **Ct.Mean** y el vector generado en "3".

```{r}
# generar tabla para los dCt_mean = Ct - mean(Ct)
table <- table[order(table$Target.Name, table$Sample.Name),] # (1)
average_ct <- tapply(table$Ct.Mean, INDEX = table$Target.Name, FUN = mean) # (2)
average_ct <- rep(average_ct, each = length(levels(table$Sample.Name))) # (3)
table$dCt_mean <- table$Ct.Mean - average_ct # (4)

head(table[order(table$Target.Name),])
```


Por último, calculamos los ∆∆Ct

1.  Parseamos el *data frame* "table" para que se quede solo con los genes *housekeeping* (introducidos por el usuario en el argumento `hk_genes`).
2.  Calculamos el promedio de los "dCt_mean" de los *housekeeping* según cada condición (cuando solo haya un gen *housekeeping*, el promedio calculado será el propio valor del "dCt_mean").
3.  Generamos un vector en el que estos promedios calculados en "2" se repitan tantas veces como distintos genes haya para cada condición.
4.  Añadimos al *data frame* dos nuevas columnas que sea la diferencia de los distintos **dCt** y el vector generado en "3" para (a) los dCt calculados respecto del control (**dCt_ctrl**) (b) los dCt calculados respecto de la media (**dCt_mean**)


Posteriormente calculamos también, para ambos casos (cálculos respecto de control o respecto de media):

-   Fold Change
-   LFC (Log Fold Change)

```{r}
# generar tabla para ddCt = dCt - dCt_housekeeping
table <- table[order(table$Sample.Name),]
hk_table <- table[which(table$Target.Name %in% hk_genes),] # (1)
hk_averages <- tapply(hk_table$dCt_mean, 
                      INDEX = hk_table$Sample.Name, 
                      FUN = mean) # (2)
hk_averages <- rep(hk_averages, each = length(levels(table$Target.Name))) # (3)
table$ddCt_ctrl <- table$dCt_ctrl - hk_averages # (4a)
table$ddCt_mean <- table$dCt_mean - hk_averages # (4b)
table$Fold.Change_ctrl <- 2^(-table$ddCt_ctrl)
table$Fold.Change_mean <- 2^(-table$ddCt_mean)
table$LFC_ctrl <- log2(table$Fold.Change_ctrl)
table$LFC_mean <- log2(table$Fold.Change_mean)
```


Por último, solo queda una cosa: quizá el usuario quiera solo los cálculos respecto del control o respecto de la media (o quizá quiera ambos). Para ello, introdujimos dos argumentos lógicos que indican si se quieren los resultados respecto del control o de la media: `minus.ctrl` y `minus.mean`, respectivamente, que tomarán el valor `TRUE` si quieren los resultados calculados de la correspondiente manera. Para devolver al usuario lo que quiere, le devolvemos el anterior *data frame* eliminando aquellas variables que no desea. Para ello ideamos un "bucle condicional de eliminación", en el que, en función de los valores de los dos mencionados argumentos, el *data frame* es parseado. Este bucle solo se corre si ambos argumentos no toman el valor `TRUE` (porque, en ese caso, no hace falta parsear el *data frame*).

```{r eval=FALSE}
if(!(minus.ctrl & minus.mean)){
  if(!minus.ctrl & !minus.mean){
    stop("At least one argument from 'minus.ctrl' and 'minus.mean' must be TRUE.")
    # detiene el código e indica que al menos uno de los argumentos 
    # tiene que ser 'TRUE'
    }
  if(!minus.ctrl){ # elimina todas las variables calculadas respecto al ctrl
    eliminate <- c("dCt_ctrl", "ddCt_ctrl", "Fold.Change_ctrl", "LFC_ctrl")
    table <- table[,!(names(table) %in% eliminate)] 
  }else if(!minus.mean){ # ídem. respecto a la media
    eliminate <- c("dCt_mean", "ddCt_mean", "Fold.Change_mean", "LFC_mean")
    table <- table[-which(table$Sample.Name == control_cond),
                     !(names(table) %in% eliminate)]
    # elimina los cálculos relativos a la referencia (ya que son 0 por definición)
  }
}
```


# Ejemplo de uso de las funciones

Para probar las funciones, vamos a utilizar el experimento 1:

```{r}
# importamos los datos de la qPCR
qPCR <- read.qPCR(file = "Plate10b.xls", 
                  results.range = "A40:AK134")
head(qPCR)
```


Antes de introducir este *data frame* a la función `qPCR.results()`, puesto que solo queremos los resultados del experimento 1 y habrá que introducirle a la función un vector con las filas donde se encuentran los resultados del experimento 1, conviene ordenar el *data frame* por "Sample Name", para que las primeras 40 filas correspondan al experimento 1 y sea más cómodo introducir dicho vector a la función.

```{r}
qPCR <- qPCR[order(qPCR$`Sample Name`),]
head(qPCR)
```


Indicamos como condición control "1Nx-" y como *housekeepings* "RP2" y "Act".

```{r}
experiment1 <- qPCR.results(qPCR, "1Nx-", c("RP2", "Act"), rows = 1:40)
head(experiment1)
```


Si queremos calcular solo respecto del control:

```{r}
experiment1bis <- qPCR.results(qPCR, "1Nx-", c("RP2", "Act"), rows = 1:40, 
                               minus.mean = FALSE)
head(experiment1bis)
```


Si ponemos ambos argumentos `minus.ctrl` y `minus.mean` como `FALSE`, veremos que obtendremos el error antes mencionado:

```{r error = TRUE}
experiment1bis <- qPCR.results(qPCR, "1Nx-", c("RP2", "Act"), rows = 1:40, 
                               minus.ctrl = FALSE, 
                               minus.mean = FALSE)
```


Por último, representamos gráficamente los resultados mediante `ggplot`:

```{r}
if (!require(ggplot2)){
  install.packages("ggplot2")
  }
library(ggplot2)

hk <- c('RP2','Act')
plot<-ggplot(experiment1[-which(experiment1$Target.Name%in%hk),], 
             aes(x = Sample.Name, y = LFC_mean))
# no metemos los housekeeping en el gráfico

plot + geom_point() +
  facet_wrap(~Target.Name, 
             scales='free_y') + # cada gráfico con escala independiente
  geom_hline(aes(yintercept=0), 
             color='red', 
             lty='dashed') + # línea roja discontinua en LFC = 0
  labs(x='Sample',y='Expression (LFC)') +
  theme_bw() + # fondo blanco
  # cambiamos los tags para que los ponga en vertical
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) 
```


# Anexo: Ayuda de funciones

En este anexo incluimos ayuda sobre las funciones que hemos definido, en un formato similar al proporcionado por RStudio.


## Ayuda de `read.qPCR()` {#ayuda-de-read.qpcr}

### Read and extract qPCR experiment data from excel file

#### Description

Reads an excel file prototype of a qPCR experiment and extracts relevant fields for data analysis.

#### Usage

```{r eval = FALSE}
read.qPCR <- function (file, 
                       sheet = "Results", 
                       results.range, 
                       columns =  c("Sample Name", "Target Name", "CT", "Ct Mean"),
                       undet.ct = "Undetermined")
```

#### Arguments

|                 |                                                                                                                                                                                                                                                                                                         |
|--------------------------|----------------------------------------------|
| `file`          | pathway to the xls/xlsx file which the data are to be read from. Each row of the table appears as one line of the file. If it does not contain an absolute path, the file name is relative to the current working directory, [getwd]{.underline}(). (For more information, read [read.csv]{.underline}) |
| `sheet`         | string name of excel's sheet where results are stored. If not specified, the default is "Results". (For more information, read [read\_.csv_excel]{.underline})                                                                                                                                          |
| `results.range` | an excel cell range to read from. (For more information, read [read\_.csv_excel]{.underline})                                                                                                                                                                                                           |
| `columns`       | a character-based vector with the names of the columns to read from. By default column's named "Sample Name", "Target Name", "CT", "Ct Mean" are read.                                                                                                                                                  |
| `undet.ct`      | string used by qPCR machine to name undetermined CT values. If not specified, the default value is "Undetermined", which ensures "CT" fields does not coerce as a character type.                                                                                                                       |

## Ayuda de `qPCR.results()` {#ayuda-de-qpcr.results}

### Compute Results of Quantitative PCR Table

#### Description

Generates a data frame with quantitative PCR statistics: delta Ct, delta delta Ct, fold change of expression and log fold change (LFC).

#### Usage

```{r eval = FALSE}
qPCR.results(qPCR_table, 
             control_cond, 
             hk_genes, 
             rows = 1:nrow(qPCR_table), 
             sample_name =  "Sample Name", 
             target_name = "Target Name", 
             ct = "CT", 
             ct_mean = "Ct Mean", 
             include.ct_mean = TRUE, 
             minus.ctrl = TRUE,
             minus.mean = TRUE)
```

#### Arguments

|                   |                                                                                                                                                                                               |
|--------------------------|----------------------------------------------|
| `qPCR_table`      | an R data frame with the results of the qPCR, such as one generated by `read.qPCR()`.                                                                                                         |
| `control_cond`    | a character indicating the condition to be considered as control or reference.                                                                                                                |
| `hk_genes`        | a character vector indicating the name of the housekeeping genes.                                                                                                                             |
| `rows`            | a numeric vector indicating the index of the rows with samples belonging to the same experiment. By default, all rows are considered to belong to the same experiment (`1:nrow(qPCR_table)`). |
| `sample_name`     | character indicating the name of the variable that stores sample names, `"Sample Name"` by default.                                                                                           |
| `target_name`     | character indicating the name of the variable that stores target (gene) names, `"Target Name"` by default.                                                                                    |
| `ct`              | character indicating the name of the variable that stores Ct values, `"CT"` by default.                                                                                                       |
| `ct_Mean`         | character indicating the name of the variable that stores Ct mean values (mean of Ct values of replicates), `"Ct Mean"` by default.                                                           |
| `include.ct_mean` | a logical value indicating whether Ct mean values (mean of Ct values of replicates) are included in the `qPCR_table` data frame, `TRUE` by default.                                           |
| `minus.ctrl`      | a logical value indicating whether delta Ct, delta delta Ct, fold change and LFC are to be calculated with respect to a control or reference condition, `TRUE` by default.                    |
| `minus.mean`      | a logical value indicating whether delta Ct, delta delta Ct, fold change and LFC are to be calculated with respect to the mean value for same genes, `TRUE` by default.                       |
